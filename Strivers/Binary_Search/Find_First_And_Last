BRUTE FORCE
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        # brute force
        index1=-1
        index2=-1
         
        for i in range(len(nums)):
            if nums[i]==target:
                if index1==-1:
                    index1=i
                
                index2=i
        return [index1,index2]
           

        return [index2,index1]
O(N)

OPTIMIZED
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        #optimized approach
        # using binary search
        first=second=-1
        i=0
        j=len(nums)-1
        while i<=j:
            mid=(i+j)//2
            if nums[mid]==target:
                first=second=mid
                while first>0 and nums[first-1]==target:
                    first-=1
                while second<len(nums)-1 and nums[second+1]==target:
                    second+=1
                break
            elif nums[mid]<target:
                i=mid+1
            else:
                j=mid-1
        return [first,second]


a. second<len(nums)-1 is used because we start second from -1 and if i keep it as len(Nums)
then index goes out of range for cases when there is only one element present

b. also first>0 and second<len(nums)-1 it is important to write them first in the AND condition
because they help in not going out of bounds while checking
