
MAIN TRICK: The main idea that led to being this q different was the use of XOR . XOR on odd element with 1 will tell us that its pair is at index-1 
whereas for even its at index+1  so we use this condition for selecting which half has our answer

This q is best understood through a dry run

class Solution:
def singleNonDuplicate(self, nums: List[int]) -> int:
        #if mid index is even it means that element already occurred before
        #if index is odd then element still needs to come later
        i=0
        j=len(nums)-1
        while i<j:
            mid=(i+j)//2
            if nums[mid]==nums[mid^1]:
                i=mid+1
            else:
                j=mid
        return nums[i]



1. Binary Search
Efficient way to search in a sorted array.
Reduces time complexity from O(n) to O(log n).
Key idea: repeatedly split the search space in half (i to j).

ðŸ”¹ 2. Mid Calculation
mid = (i + j) // 2
(i+j)//2 gives the middle index.
In binary search, mid is used to decide which half to continue searching.
Watch for integer division in Python (//).

ðŸ”¹ 3. XOR Trick (mid ^ 1)
XOR flips the last bit of mid.
If mid is even â†’ mid ^ 1 = mid + 1 (next index, the pair)
If mid is odd â†’ mid ^ 1 = mid - 1 (previous index, the pair)
Purpose: efficiently find the expected pair index without using if-else.
Helps decide which side of the array the single element lies on.

ðŸ”¹ 4. Pair Property in Sorted Array
All elements appear exactly twice, except one single element.
Before single element â†’ pairs are (even, odd)
After single element â†’ pairs are (odd, even) (shift happens)
Checking nums[mid] == nums[mid ^ 1] tells whether the single element is left or right.

ðŸ”¹ 5. Binary Search Bounds
while i < j:
    j = mid   # not mid-1
i < j stops when search space is one element.
j = mid keeps mid in the search space because mid might itself be the single element.

ðŸ”¹ 6. Time Complexity
Binary search reduces search space by half each time â†’ O(log n).
Checking pair with XOR â†’ O(1) per iteration.
Overall â†’ O(log n) time, O(1) space.

ðŸ”¹ 7. Space Complexity
Constant extra space (i, j, mid) â†’ O(1).

ðŸ”¹ 8. Edge Cases
Single element at start â†’ nums[0]
Single element at end â†’ nums[-1]
The code handles these automatically because i and j converge correctly.

âœ… Summary (Intuition)
The array is split into halves using binary search.
XOR finds the â€œexpected pairâ€ index.
Compare with the pair to decide left or right search.
Converge to the single element in logarithmic time.
