
BRUTE FORCE
import numpy as np
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        #brute force
        n=np.ravel(matrix)
        n.sort()
        i=0
        j=len(n)-1
        while i<=j:
            mid=(i+j)//2
            if n[mid]==target:
                return True
            elif n[mid]<target:
                i=mid+1
            else:
                j=mid-1
        return False


OPTIMIZED VERSION
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        rows=len(matrix)
        cols=len(matrix[0])
        i=0
        j=cols-1
        while i<rows and j>=0:
            if matrix[i][j]==target:
                return True
            elif matrix[i][j]>target:
                j-=1
            else:
                i+=1
        return False


The reason for the condition while i<rows and j>=0 is that i represents number of rows so it needs to be compared with the max limit that is total number of rows 
and same for columns
We compare indices with their max limits , when writing while i<=j we its because j was at the max limit in array
but in case of 2d the max limits for both indices change



TC -- O(M+N)
âœ… Why O(m + n)?
You start at the top-right corner:
At each step, you either:
Move left one column (j -= 1), OR
Move down one row (i += 1).
So in total:

You can move down at most m times (once per row).

You can move left at most n times (once per column).

Once youâ€™ve moved down m rows or left n columns, youâ€™re out of the matrix â†’ search ends.

ðŸ‘‰ That means the maximum number of moves = m + n.
Not m * n, because you donâ€™t scan every element â€” youâ€™re â€œcutting offâ€ parts of the matrix at each step.
