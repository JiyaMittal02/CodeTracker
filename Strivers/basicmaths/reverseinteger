class Solution:
    def reverse(self, x: int) -> int:
        check=x<0
        x=abs(x)
        temp=int(str(x)[::-1])
        if check:
            temp=-temp
        if temp<-2**31 or temp>2**31-1:  #because it is the result that can go out of bounds not the original number
            return 0
        return temp
    
        

JAVA

class Solution {
    public int reverse(int x)
    {
        //reversing an integer , edge case : negative number , 0 
        //counting digits
        
    int result = 0;

    while (x != 0)
    {
        int tail = x % 10;
        int newResult = result * 10 + tail;
        if ((newResult - tail) / 10 != result)          //VERY IMPORTANT SAVES FROM HARDCODING THE OVERFLOW CONDITIONS
        { return 0; }
        result = newResult;
        x = x / 10;
    }

    return result;

    }
}
 Java doesnt throw overflow error instead it wraps around i.e
Because in Java:

int overflow does NOT throw an error

It silently wraps around â†’ dangerous

public class three 
{
	public static void main(String[] args) 
	{
		int a=Integer.MIN_VALUE;
		System.out.println(a-1);
		int b=Integer.MAX_VALUE;
		System.out.println(b+1);
	}
}
output : 2147483647
-2147483648


        
