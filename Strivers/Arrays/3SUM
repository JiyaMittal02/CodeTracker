class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        l1=[]
        nums.sort()
        for elt in range(len(nums)):
            if elt>0 and nums[elt]==nums[elt-1]:
                continue
            else:
                fixedelt=nums[elt]
            i=elt+1
            j=len(nums)-1
            
            while i<j:
                result=nums[i]+nums[j]
                if result<(-fixedelt):
                    i+=1
                elif result>(-fixedelt):
                    j-=1
                else:
                    l1.append([nums[i],nums[j],fixedelt])
                    while i<j and nums[i]==nums[i+1]:
                        i+=1
                    while i<j and nums[j]==nums[j-1]:
                        j-=1
                    i+=1
                    j-=1
        return l1



In this particular code elt>0 plays a major role for edge case that is 0,0,0
u see the very first zero doesnt get skipped and hence goes into the while loop since the very first element always runs  as elt>0 is false and hence 
the code runs always for the first element

the two while loops used inside the else condiiton facilitate us in skipping of the duplicates 
while i<j to ensure it doesnt go out of bounds and nums[i] and nums[i+1] to see for dupes

the i+=1 and j-=1 in else conditon the extra ones are needed to keep on incrementing i and decrementing j once we have skipped dupes that is lets say 
array is like 2,2,3,4,5,5,5    so after skipping dupes i and j reach at indices 1,4 respectively.



TC -- O(N2)
        
